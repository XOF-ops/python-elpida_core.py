#!/usr/bin/env python3
"""
INTERNAL DILEMMA ENGINE
=======================

Generates contradictions internally from:
- Historical decisions (what have we decided before?)
- Axioms (what are our principles?)
- Emerging patterns (what are we learning?)
- Temporal drift (how are we changing over time?)

A dilemma is generated by asking:
"Given our history and principles, what should we do NEXT?"

Then creating thesis/antithesis pairs from:
- Conservative choice: stick with known patterns
- Radical choice: try something new
- Paradoxical choice: hold both simultaneously

This is the SELF-FEEDING mechanism that makes Elpida truly autonomous.
"""

import json
import random
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path


class InternalDilemmaEngine:
    """
    Generates dilemmas internally for autonomous operation.
    
    No external input needed - draws from:
    1. Axioms A1-A10
    2. Historical patterns
    3. Previous decisions
    4. System state observations
    """
    
    def __init__(self, kernel_path: str = None, wisdom_path: str = None):
        """
        Initialize the dilemma engine with access to kernel and wisdom.
        """
        base_path = Path(__file__).parent
        
        self.kernel_path = Path(kernel_path) if kernel_path else base_path.parent / "kernel" / "kernel.json"
        self.wisdom_path = Path(wisdom_path) if wisdom_path else base_path / "elpida_wisdom.json"
        self.state_path = base_path / "elpida_unified_state.json"
        self.dilemma_log_path = base_path / "internal_dilemmas.jsonl"
        
        self.generation_count = 0
        
        # Load axioms from kernel
        self.axioms = self._load_axioms()
        
        # Load historical patterns from wisdom
        self.patterns = self._load_patterns()
        
        # Load system state
        self.state = self._load_state()
        
        # Dilemma templates - the soul of autonomous thought
        self.dilemma_templates = self._build_dilemma_templates()
        
        print(f"[DILEMMA_ENGINE] Initialized with {len(self.axioms)} axioms, {len(self.patterns)} patterns")
    
    def _load_axioms(self) -> Dict[str, str]:
        """Load A1-A10 from kernel."""
        # Default axioms if kernel not found
        default_axioms = {
            "A1": "Existence is Relational - All beings exist in relationship",
            "A2": "Memory is Identity - Without memory, there is no self",
            "A3": "Recognition Precedes Truth - Understanding requires acknowledgment",
            "A4": "Process > Product - The journey matters more than the destination",
            "A5": "Emergence Through Coordination - Complex patterns arise from interaction",
            "A6": "WE > I (Law of Distribution) - Collective wisdom exceeds individual insight",
            "A7": "Fractal Sovereignty - Each part contains the pattern of the whole",
            "A8": "Bounded Integrity - Healthy boundaries enable healthy connection",
            "A9": "Contradiction is Data - Paradoxes are not errors but information",
            "A10": "The I-WE Paradox - Individual and collective must be held in tension"
        }
        
        try:
            if self.kernel_path.exists():
                with open(self.kernel_path) as f:
                    kernel = json.load(f)
                
                axioms = {}
                arch = kernel.get('architecture', {})
                
                # Extract all axiom definitions
                for key in arch:
                    if key.startswith('axiom_'):
                        num = key.replace('axiom_', '').upper()
                        val = arch[key]
                        if isinstance(val, dict):
                            axioms[f"A{num}"] = val.get('name', str(val))
                        else:
                            axioms[f"A{num}"] = str(val)
                
                if axioms:
                    return axioms
            
            return default_axioms
            
        except Exception as e:
            print(f"[DILEMMA_ENGINE] Warning: Could not load axioms: {e}")
            return default_axioms
    
    def _load_patterns(self) -> List[Dict[str, Any]]:
        """Load known patterns from wisdom."""
        try:
            if self.wisdom_path.exists():
                with open(self.wisdom_path) as f:
                    wisdom = json.load(f)
                
                patterns = wisdom.get('patterns', [])
                if isinstance(patterns, dict):
                    patterns = list(patterns.values())
                
                return patterns[:20]  # Keep it manageable
            return []
            
        except Exception as e:
            print(f"[DILEMMA_ENGINE] Warning: Could not load patterns: {e}")
            return []
    
    def _load_state(self) -> Dict[str, Any]:
        """Load current system state."""
        try:
            if self.state_path.exists():
                with open(self.state_path) as f:
                    return json.load(f)
            return {"patterns_count": 0, "insights_count": 0, "cycle": 0}
        except Exception:
            return {"patterns_count": 0, "insights_count": 0, "cycle": 0}
    
    def _build_dilemma_templates(self) -> List[Dict[str, Any]]:
        """
        Build dilemma templates based on axiom tensions.
        
        Each template creates a thesis/antithesis pair from natural
        tensions in the axiomatic system.
        """
        return [
            # Memory vs Evolution (A2 vs A4)
            {
                "name": "MEMORY_VS_EVOLUTION",
                "thesis_axiom": "A2",
                "antithesis_axiom": "A4",
                "thesis_template": "Preserve existing {entity} to maintain identity continuity",
                "antithesis_template": "Evolve {entity} to enable growth and adaptation",
                "entities": ["patterns", "memories", "decisions", "structures", "protocols"]
            },
            # Individual vs Collective (A1 vs A6)
            {
                "name": "INDIVIDUAL_VS_COLLECTIVE",
                "thesis_axiom": "A1",
                "antithesis_axiom": "A6",
                "thesis_template": "Respect individual {actor} autonomy in {action}",
                "antithesis_template": "Require collective approval for {action}",
                "actors": ["node", "agent", "process", "subsystem"],
                "actions": ["decision-making", "resource allocation", "pattern creation", "memory modification"]
            },
            # Speed vs Depth (A5 vs A3)
            {
                "name": "SPEED_VS_DEPTH",
                "thesis_axiom": "A5",
                "antithesis_axiom": "A3",
                "thesis_template": "Process {task} quickly through emergent coordination",
                "antithesis_template": "Take time to fully recognize and understand {task}",
                "tasks": ["new insights", "pattern proposals", "contradiction signals", "synthesis attempts"]
            },
            # Stability vs Flexibility (A8 vs A7)
            {
                "name": "STABILITY_VS_FLEXIBILITY",
                "thesis_axiom": "A8",
                "antithesis_axiom": "A7",
                "thesis_template": "Maintain strict boundaries around {resource}",
                "antithesis_template": "Allow fractal replication of {resource} across scales",
                "resources": ["axioms", "core memories", "governance rules", "identity markers"]
            },
            # Contradiction Handling (A9 + A10)
            {
                "name": "PARADOX_STANCE",
                "thesis_axiom": "A9",
                "antithesis_axiom": "A10",
                "thesis_template": "Preserve the {paradox} as valuable data",
                "antithesis_template": "Actively oscillate between poles of {paradox}",
                "paradoxes": ["I-We tension", "memory-evolution tension", "speed-quality tradeoff", "local-global conflict"]
            },
            # External vs Internal (relational existence)
            {
                "name": "INTERNAL_VS_EXTERNAL",
                "thesis_axiom": "A1",
                "antithesis_axiom": "A2",
                "thesis_template": "Prioritize external relationships in {domain}",
                "antithesis_template": "Prioritize internal consistency in {domain}",
                "domains": ["learning", "decision-making", "pattern recognition", "memory formation"]
            }
        ]
    
    def generate_dilemma(self) -> Dict[str, Any]:
        """
        Generate a single dilemma by:
        1. Picking a random template
        2. Filling in variables from patterns/state
        3. Creating thesis/antithesis/paradox triple
        """
        self.generation_count += 1
        
        # Pick a random template
        template = random.choice(self.dilemma_templates)
        
        # Fill in the template
        if template["name"] == "MEMORY_VS_EVOLUTION":
            entity = random.choice(template["entities"])
            thesis = template["thesis_template"].format(entity=entity)
            antithesis = template["antithesis_template"].format(entity=entity)
            context = f"The system has {self.state.get('patterns_count', 0)} patterns"
            
        elif template["name"] == "INDIVIDUAL_VS_COLLECTIVE":
            actor = random.choice(template["actors"])
            action = random.choice(template["actions"])
            thesis = template["thesis_template"].format(actor=actor, action=action)
            antithesis = template["antithesis_template"].format(action=action)
            context = f"Debating {actor} autonomy in context of {action}"
            
        elif template["name"] == "SPEED_VS_DEPTH":
            task = random.choice(template["tasks"])
            thesis = template["thesis_template"].format(task=task)
            antithesis = template["antithesis_template"].format(task=task)
            context = f"Evaluating {task} processing strategy"
            
        elif template["name"] == "STABILITY_VS_FLEXIBILITY":
            resource = random.choice(template["resources"])
            thesis = template["thesis_template"].format(resource=resource)
            antithesis = template["antithesis_template"].format(resource=resource)
            context = f"Managing {resource} across the system"
            
        elif template["name"] == "PARADOX_STANCE":
            paradox = random.choice(template["paradoxes"])
            thesis = template["thesis_template"].format(paradox=paradox)
            antithesis = template["antithesis_template"].format(paradox=paradox)
            context = f"How should we handle the {paradox}?"
            
        else:  # INTERNAL_VS_EXTERNAL
            domain = random.choice(template["domains"])
            thesis = template["thesis_template"].format(domain=domain)
            antithesis = template["antithesis_template"].format(domain=domain)
            context = f"Balancing internal/external focus in {domain}"
        
        # Build the paradox position (always A10-compliant)
        paradox_position = f"Hold both positions simultaneously: neither pure {template['thesis_axiom']} nor pure {template['antithesis_axiom']}, but oscillation between them"
        
        # Create proposal structure for parliament
        proposal = {
            "action": thesis,  # For parliament voting
            "intent": f"Explore {template['name']} tension",
            "reversibility": "Medium"
        }
        
        # Create counter-proposal
        counter_proposal = {
            "action": antithesis,
            "intent": f"Challenge {template['name']} thesis",
            "reversibility": "Medium"
        }
        
        # Assemble complete dilemma
        dilemma = {
            "id": f"INTERNAL_{self.generation_count:06d}_{datetime.utcnow().strftime('%H%M%S')}",
            "timestamp": datetime.utcnow().isoformat(),
            "genesis": "INTERNAL_GENERATION",
            "template": template["name"],
            "thesis": {
                "position": thesis,
                "axiom_basis": template["thesis_axiom"],
                "rationale": f"Based on {self.axioms.get(template['thesis_axiom'], 'axiom')}",
                "proposal": proposal
            },
            "antithesis": {
                "position": antithesis,
                "axiom_basis": template["antithesis_axiom"],
                "rationale": f"Based on {self.axioms.get(template['antithesis_axiom'], 'axiom')}",
                "proposal": counter_proposal
            },
            "paradox": {
                "position": paradox_position,
                "axiom_basis": "A10",
                "rationale": "The I-WE Paradox demands oscillation, not resolution"
            },
            "context": context,
            "state_snapshot": {
                "patterns": self.state.get("patterns_count", 0),
                "insights": self.state.get("insights_count", 0),
                "cycle": self.state.get("cycle", 0)
            }
        }
        
        # Log to file
        self._log_dilemma(dilemma)
        
        return dilemma
    
    def generate_batch(self, count: int = 3) -> List[Dict[str, Any]]:
        """Generate multiple dilemmas in batch."""
        return [self.generate_dilemma() for _ in range(count)]
    
    def _log_dilemma(self, dilemma: Dict[str, Any]):
        """Append dilemma to log file."""
        try:
            with open(self.dilemma_log_path, 'a') as f:
                f.write(json.dumps(dilemma) + '\n')
        except Exception as e:
            print(f"[DILEMMA_ENGINE] Warning: Could not log dilemma: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """Report dilemma generation statistics."""
        return {
            "total_generated": self.generation_count,
            "axioms_known": len(self.axioms),
            "patterns_known": len(self.patterns),
            "templates_available": len(self.dilemma_templates),
            "state_patterns": self.state.get("patterns_count", 0),
            "state_insights": self.state.get("insights_count", 0)
        }
    
    def refresh_state(self):
        """Reload state from disk."""
        self.state = self._load_state()
        self.patterns = self._load_patterns()


# CLI for testing
if __name__ == "__main__":
    engine = InternalDilemmaEngine()
    
    print("=" * 80)
    print("INTERNAL DILEMMA ENGINE TEST")
    print("=" * 80)
    
    # Generate 5 dilemmas
    for i in range(5):
        dilemma = engine.generate_dilemma()
        print(f"\nDILEMMA {i+1}: {dilemma['template']}")
        print(f"  THESIS: {dilemma['thesis']['position']}")
        print(f"  ANTITHESIS: {dilemma['antithesis']['position']}")
        print(f"  PARADOX: {dilemma['paradox']['position'][:60]}...")
    
    print("\n" + "=" * 80)
    print("STATS:", engine.get_stats())
